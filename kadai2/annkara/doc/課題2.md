# 課題2

## io.Readerとio.Writerについて調べてみよう

- 標準パッケージでどのように使われているか
- io.Readerとio.Writerがあることでどういう利点があるのか具体例を挙げて考えてみる

## 標準パッケージでどのように使われているか

入出力処理を伴うパッケージ内で定義されている構造体の要素、また、その構造体を生成するNewXXX関数などのパラメータとして利用されていることが多いように感じる。  

io.Writer/io.Readerはともに入出力処理のシンプルなインターフェースを提供し、インターフェースの実装を用途に応じた処理でラッピングすることで、柔軟な入出力処理を実現している印象を受けた。

### io.Writer

[golang/go内でのio.Writerの利用箇所](https://github.com/golang/go/search?q=%22io.Writer%22&unscoped_q=%22io.Writer%22)

[src/bufio/bufio.goでの利用箇所](https://github.com/golang/go/blob/3ed5a53f9d1c9713c7d2748f7744534e404b80de/src/bufio/bufio.go#L544)

### io.Reader

[golang/go内でのio.Readerの利用箇所](https://github.com/golang/go/search?q=%22io.Reader%22&unscoped_q=%22io.Reader%22)

[src/archive/tar/reader.goでの利用箇所](https://github.com/golang/go/blob/50bd1c4d4eb4fac8ddeb5f063c099daccfb71b26/src/archive/tar/reader.go#L18)

## io.Readerとio.Writerがあることでどういう利点があるのか具体例を挙げて考えてみる

### 利点

- 実装の切り替えが容易であること

```Go
func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)
```

fmt.Printf関数は、第一パラメータにio.Writer型を受け取る。  
そのため、io.Writer型を実装する具象型であればどのような型であっても受け取ることが可能。  

```Go

// fmt.Printf関数
// 実装内のfmt.Fprintf関数内で、os.Stdoutをパラメータとして渡しており
// 標準出力にフォーマットされたデータが表示される
func Printf(format string, a ...interface{}) (n int, err error) {
    return Fprintf(os.Stdout, format, a...)
}

// go docコマンドのusageの出力関数
func usage() {
    fmt.Fprintf(os.Stderr, "Usage of [go] doc:\n")
    ...
}

// net/httpパッケージのHandlerインターフェースとResponseWriter型
// ResponseWriter型がio.Writer型を満たすため、ServeHTTP内でResponseWriterを
// 通じてHTTPのレスポンスを応答することが可能
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
type ResponseWriter interface {
    Header() Header
    Write([]byte) (int, error)
    WriteHeader(statusCode int)
}

```

高度に抽象化されることによって、入出力先の対象を切り替えることが容易になっている。
