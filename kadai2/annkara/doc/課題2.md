# 課題2

## io.Readerとio.Writerについて調べてみよう

- 標準パッケージでどのように使われているか
- io.Readerとio.Writerがあることでどういう利点があるのか具体例を挙げて考えてみる

## 標準パッケージでどのように使われているか

入出力処理を伴うパッケージ内で定義されている構造体の要素、また、その構造体を生成するNewXXX関数などのパラメータとして利用されていることが多いように感じる。  

io.Writer/io.Readerはともに入出力処理のシンプルなインターフェースを提供し、インターフェースの実装を用途に応じた処理でラッピングすることで、柔軟な入出力処理を実現している印象を受けた。

### io.Writer

[golang/go内でのio.Writerの利用箇所](https://github.com/golang/go/search?q=%22io.Writer%22&unscoped_q=%22io.Writer%22)

[src/bufio/bufio.goでの利用箇所](https://github.com/golang/go/blob/3ed5a53f9d1c9713c7d2748f7744534e404b80de/src/bufio/bufio.go#L544)

### io.Reader

[golang/go内でのio.Readerの利用箇所](https://github.com/golang/go/search?q=%22io.Reader%22&unscoped_q=%22io.Reader%22)

[src/archive/tar/reader.goでの利用箇所](https://github.com/golang/go/blob/50bd1c4d4eb4fac8ddeb5f063c099daccfb71b26/src/archive/tar/reader.go#L18)

## io.Readerとio.Writerがあることでどういう利点があるのか具体例を挙げて考えてみる

### 利点

- 実装の切り替えが容易であること

```Go
//fmt.Fprintf関数は、第一パラメータにio.Writer型を受け取る。  
//そのため、io.Writer型を実装する具象型であればどのような型であっても受け取ることが可能。
func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)

// 標準出力への出力
func Printf(format string, a ...interface{}) (n int, err error) {
    return Fprintf(os.Stdout, format, a...)
}
// 標準エラー出力への出力
func usage() {
    fmt.Fprintf(os.Stderr, "Usage of [go] doc:\n")
    ...
}

// net/httpパッケージのHandlerインターフェースとResponseWriter型
// ResponseWriter型がio.Writer型を満たすため、ServeHTTP関数内でResponseWriterを
// 通じてレスポンスを応答することが可能
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
type ResponseWriter interface {
    Header() Header
    Write([]byte) (int, error)
    WriteHeader(statusCode int)
}
// net/httpパッケージのtriv.goからの抜粋
func (ch Chan) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    io.WriteString(w, fmt.Sprintf("channel send #%d\n", <-ch))
}
// io.WriteString関数の抜粋
// 第一パラメータがio.Writer型を受け取る
func WriteString(w Writer, s string) (n int, err error) {
    if sw, ok := w.(stringWriter); ok {
        return sw.WriteString(s)
    }
    return w.Write([]byte(s))
}
```
